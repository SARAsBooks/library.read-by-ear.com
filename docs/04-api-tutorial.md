# Read-by-Ear API Tutorial

> **⚠️ LLM-Generated Documentation Disclaimer**: This documentation was generated by an AI language model and has not yet been edited or verified by the Sara's Books team. While efforts have been made to ensure accuracy, please verify code examples and file paths before use. Report any issues or inaccuracies to the development team.

This comprehensive tutorial covers all API endpoints in the Read-by-Ear platform, designed to help new developers understand the patterns, authentication, and database integration used throughout the codebase.

## Table of Contents

1. [API Architecture Overview](#api-architecture-overview)
2. [Core API Endpoints](#core-api-endpoints)
3. [Authentication & Session Management](#authentication--session-management)
4. [Database Integration Patterns](#database-integration-patterns)
5. [Error Handling & Monitoring](#error-handling--monitoring)
6. [Environment Configuration](#environment-configuration)
7. [Best Practices](#best-practices)

## API Architecture Overview

The Read-by-Ear API is built using **Next.js App Router** with API routes located in `src/app/api/`. The architecture follows RESTful principles with strong TypeScript typing and includes:

- **Next.js API Routes**: Located in [`src/app/api/`](../src/app/api/)
- **Server Actions**: Located in [`src/backend/actions/`](../src/backend/actions/)
- **Database Layer**: Drizzle ORM with PostgreSQL in [`src/backend/db/`](../src/backend/db/)
- **Session Management**: Iron Session for secure cookie-based sessions

### Current API Structure

```
src/app/api/
├── ping/route.ts           # Health check endpoint
├── session/route.ts        # Session management
├── student/new/route.ts    # Student creation
├── errors/route.ts         # Error reporting system
├── learning-audit/route.ts # Learning analytics audit
└── convex/token/route.ts   # Convex authentication
```

## Core API Endpoints

### 1. Health Check Endpoint (`/api/ping`)

**Purpose**: Simple connectivity testing and performance monitoring

**Source**: [`src/app/api/ping/route.ts`](../src/app/api/ping/route.ts)

```typescript
export async function GET() {
  return NextResponse.json({
    status: "ok",
    timestamp: new Date().toISOString(),
    server: "read-by-ear-api",
  });
}

export async function HEAD() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Cache-Control": "no-cache, no-store, must-revalidate",
      "X-Timestamp": new Date().toISOString(),
    },
  });
}
```

**Usage Examples**:

```bash
# GET request for full response
curl https://library.read-by-ear.com/api/ping

# HEAD request for headers only (performance monitoring)
curl -I https://library.read-by-ear.com/api/ping
```

**Response Format**:

```json
{
  "status": "ok",
  "timestamp": "2025-08-09T10:30:00.000Z",
  "server": "read-by-ear-api"
}
```

### 2. Session Management (`/api/session`)

**Purpose**: Retrieve current session information

**Source**: [`src/app/api/session/route.ts`](../src/app/api/session/route.ts)

```typescript
import { NextResponse } from "next/server";
import { getSession } from "@/backend/actions/session";

export async function GET() {
  const session = await getSession();
  return NextResponse.json(session);
}
```

This endpoint integrates with the session management system in [`src/backend/actions/session.ts`](../src/backend/actions/session.ts) which uses Iron Session for secure cookie-based authentication.

**Response Format** (from [`src/lib/types/session.ts`](../src/lib/types/session.ts)):

```json
{
  "sessionId": "uuid-v4-string",
  "studentId": "uuid-v4-string",
  "lastActive": 1691578800000,
  "anonymous": true,
  "authenticated": false,
  "deviceOwnership": "private",
  "saveProgress": "local",
  "useConvex": false
}
```

### 3. Student Creation (`/api/student/new`)

**Purpose**: Create new student sessions with geolocation tracking

**Source**: [`src/app/api/student/new/route.ts`](../src/app/api/student/new/route.ts)

```typescript
import { after } from "next/server";
import { NextResponse, type NextRequest } from "next/server";
import { geolocation, ipAddress } from "@vercel/functions";
import { v4 as uuid } from "uuid";
import { getSession, updateSession } from "@/backend/actions/session";

export async function GET(request: NextRequest) {
  const session = await getSession();
  session.studentId = uuid();
  await updateSession(session);
  const response = NextResponse.json(session);
  const details = geolocation(request);
  const ip = ipAddress(request);
  after(async () => {
    console.log("New studentId:", session.studentId);
    console.log(details);
    console.log(ip);
  });
  return response;
}
```

**Key Features**:

- Generates new UUID for student ID
- Updates session with new student information
- Logs geolocation and IP address using Vercel's functions
- Uses `after()` for non-blocking async logging

### 4. Error Reporting System (`/api/errors`)

**Purpose**: Centralized error tracking and monitoring system

**Source**: [`src/app/api/errors/route.ts`](../src/app/api/errors/route.ts)

This endpoint implements a comprehensive error reporting system with deduplication, statistics, and environment-aware configuration.

#### POST /api/errors - Report Client-Side Errors

```typescript
interface ErrorReport {
  errorId: string;
  timestamp: number;
  error: {
    name: string;
    message: string;
    stack?: string;
  };
  errorInfo?: {
    componentStack?: string;
    errorBoundary?: string;
  };
  context: {
    url: string;
    userAgent: string;
    environment: string;
    version: string;
  };
}

export async function POST(request: NextRequest) {
  try {
    const envConfig = config.getConfig();

    // Only accept error reports if error reporting is enabled
    if (!envConfig.features.enableErrorReporting) {
      return NextResponse.json(
        { error: "Error reporting disabled" },
        { status: 403 },
      );
    }

    const reportData = (await request.json()) as unknown;

    if (!isValidErrorReport(reportData)) {
      return NextResponse.json(
        { error: "Invalid error report format" },
        { status: 400 },
      );
    }

    // ... error storage and deduplication logic
  } catch (error) {
    console.error("[ErrorAPI] Error processing error report:", error);
    return NextResponse.json(
      { error: "Failed to process error report" },
      { status: 500 },
    );
  }
}
```

#### GET /api/errors - Error Statistics (Development Only)

```typescript
export async function GET(request: NextRequest) {
  try {
    const envConfig = config.getConfig();

    // Only allow in development or with proper auth
    if (envConfig.isProduction) {
      return NextResponse.json(
        { error: "Not available in production" },
        { status: 403 },
      );
    }

    const { searchParams } = new URL(request.url);
    const environment = searchParams.get("environment");
    const limit = parseInt(searchParams.get("limit") ?? "50", 10);

    // Filter and return error statistics
    // ...
  } catch (error) {
    // Error handling
  }
}
```

**Key Features**:

- Error deduplication based on name, message, and component
- Environment-aware configuration
- In-memory storage with cleanup policies
- Background forwarding to external services in production
- Comprehensive error statistics for monitoring

### 5. Learning Analytics Audit (`/api/learning-audit`)

**Purpose**: Background sync API for learning records audit trail

**Source**: [`src/app/api/learning-audit/route.ts`](../src/app/api/learning-audit/route.ts)

#### POST /api/learning-audit - Sync Learning Records

This endpoint maintains an audit trail in PostgreSQL while using Convex as the working set.

```typescript
import { insertFluencyRecords } from "@/backend/db/fluency-records";
import type { FluencyRecord } from "@/lib/types/fluency-record";

export async function POST(request: NextRequest) {
  try {
    const body = (await request.json()) as {
      records: unknown[];
      studentId: unknown;
      source?: string;
    };
    const { records, studentId, source } = body;

    // Validate request
    if (!Array.isArray(records) || typeof studentId !== "string") {
      return NextResponse.json(
        { error: "Invalid request: records array and studentId required" },
        { status: 400 },
      );
    }

    // Validate that records are FluencyRecord format
    const validRecords: FluencyRecord[] = records.map((record: unknown) => {
      // ... validation logic
      return {
        studentId: validRecord.studentId,
        word: validRecord.word,
        response: validRecord.response,
        timestamp: new Date(validRecord.timestamp),
      };
    });

    console.log(
      `[Audit] Syncing ${validRecords.length} learning records to PostgreSQL`,
      {
        studentId,
        source: source ?? "convex",
        recordCount: validRecords.length,
        words: [...new Set(validRecords.map((r) => r.word))],
      },
    );

    // Insert records into PostgreSQL
    await insertFluencyRecords(validRecords);

    return NextResponse.json({
      success: true,
      recordsProcessed: validRecords.length,
      studentId,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error(
      "[Audit] Error syncing learning records to PostgreSQL:",
      error,
    );

    return NextResponse.json(
      {
        error: "Failed to sync learning records to audit database",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 },
    );
  }
}
```

#### GET /api/learning-audit - Audit Summary

```typescript
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const studentId = searchParams.get("studentId");
    const summary = searchParams.get("summary") === "true";

    if (!studentId) {
      return NextResponse.json(
        { error: "studentId query parameter required" },
        { status: 400 },
      );
    }

    if (summary) {
      return NextResponse.json({
        studentId,
        auditEnabled: true,
        lastChecked: new Date().toISOString(),
        message: "Audit trail is active for learning records",
      });
    }

    return NextResponse.json(
      { error: "Only summary view is currently supported" },
      { status: 400 },
    );
  } catch (error) {
    console.error("[Audit] Error checking audit status:", error);
    return NextResponse.json(
      { error: "Failed to check audit status" },
      { status: 500 },
    );
  }
}
```

### 6. Convex Authentication Token (`/api/convex/token`)

**Purpose**: Generate authentication tokens for Convex integration

**Source**: [`src/app/api/convex/token/route.ts`](../src/app/api/convex/token/route.ts)

```typescript
export async function POST(request: NextRequest) {
  try {
    const body = (await request.json()) as {
      studentId: string;
      sessionId?: string;
      userId?: string;
    };
    const { studentId, sessionId } = body;

    // TODO: Replace with actual auth.sara.ai API call
    // For now, generate a simple development token
    const token = generateDevelopmentToken(studentId, sessionId);

    return NextResponse.json({ token });
  } catch (error) {
    console.error("Token generation error:", error);
    return NextResponse.json(
      { error: "Failed to generate token" },
      { status: 500 },
    );
  }
}

function generateDevelopmentToken(
  studentId: string,
  sessionId?: string,
): string {
  // Simple development token - replace with proper JWT from auth.sara.ai
  const payload = {
    sub: studentId,
    sessionId: sessionId,
    iss: "read-by-ear-dev",
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 3600, // 1 hour
  };

  return btoa(JSON.stringify(payload));
}
```

**Important**: This is a development-only implementation. Production should integrate with `auth.sara.ai` for proper JWT token generation.

## Authentication & Session Management

The application uses **Iron Session** for secure, encrypted session management.

### Session Architecture

**Source**: [`src/backend/actions/session.ts`](../src/backend/actions/session.ts)

```typescript
"use server";
import type { SessionOptions } from "iron-session";
import { getIronSession } from "iron-session";
import { cookies } from "next/headers";
import type { Session } from "@/lib/types/session";

const sessionOptions: SessionOptions = {
  password: "complex_password_at_least_32_characters_long",
  cookieName: "iron-examples-app-router-server-component-and-action",
  cookieOptions: {
    secure: true,
  },
};

export async function getSession(): Promise<Session> {
  const ironSession = await getIronSession<Session>(
    await cookies(),
    sessionOptions,
  );
  const newSession: Session = {
    ...defaultSession,
    ...ironSession,
    sessionId:
      ironSession.sessionId &&
      ironSession.lastActive > Date.now() - 15 * 60 * 1000
        ? ironSession.sessionId
        : uuid(),
    studentId: ironSession.studentId ?? uuid(),
    lastActive: Date.now(),
  };
  // ... session merging and saving logic
  return ironSession;
}
```

### Session Types

**Source**: [`src/lib/types/session.ts`](../src/lib/types/session.ts)

```typescript
export type Session = {
  sessionId?: string;
  studentId?: string;
  lastActive: number;
  anonymous: boolean;
  authenticated: boolean;
  deviceOwnership?: "public" | "private" | "family" | "school";
  saveProgress?: "local" | "sync";
  useConvex?: boolean;
  userId?: string;
  students?: Student[];
  progressiveWebApp?: "iOS" | "Android" | "other";
  notificationsEnabled?: Notifications;
};
```

### Key Session Functions

1. **`getSession()`**: Retrieve or create session with automatic UUID generation
2. **`updateSession(session)`**: Update existing session data
3. **`startSyncLocal(session)`**: Sync local session data to server
4. **`destroySession()`**: Clear session data

## Database Integration Patterns

The application uses **Drizzle ORM** with PostgreSQL for the audit trail.

### Database Schema

**Source**: [`src/backend/db/schema.ts`](../src/backend/db/schema.ts)

The main audit table stores fluency learning records:

```sql
CREATE TABLE reader_responses (
  student_id VARCHAR NOT NULL,
  word VARCHAR NOT NULL,
  response INTEGER NOT NULL,
  timestamp TIMESTAMP NOT NULL
);
```

### Database Operations

**Source**: [`src/backend/db/fluency-records.ts`](../src/backend/db/fluency-records.ts)

#### Query Fluency Records with Window Functions

```typescript
export async function queryFluencyRecords(
  studentId: string,
): Promise<FluencyRecord[]> {
  const rankedResultsSubquery = db
    .select({
      studentId: readerResponses.studentId,
      word: readerResponses.word,
      response: readerResponses.response,
      timestamp: readerResponses.timestamp,
      // Use window function for latest 10 responses per word
      rn: sql<number>`row_number() over (partition by ${readerResponses.word} order by ${readerResponses.timestamp} desc)`.as(
        "rn",
      ),
    })
    .from(readerResponses)
    .where(eq(readerResponses.studentId, studentId))
    .as("ranked_results");

  const result = await db
    .select({
      studentId: rankedResultsSubquery.studentId,
      word: rankedResultsSubquery.word,
      response: rankedResultsSubquery.response,
      timestamp: rankedResultsSubquery.timestamp,
    })
    .from(rankedResultsSubquery)
    .where(lte(rankedResultsSubquery.rn, 10))
    .orderBy(rankedResultsSubquery.word, rankedResultsSubquery.rn);

  return result;
}
```

#### Insert Fluency Records

```typescript
export async function insertFluencyRecords(
  records: FluencyRecord[],
): Promise<void> {
  await db
    .insert(readerResponses)
    .values(records)
    .onConflictDoNothing()
    .catch((error) => {
      throw new Error(`Error inserting fluency records: ${error}`);
    });
}
```

### Key Database Patterns

1. **Window Functions**: Used for complex queries like "latest 10 responses per word"
2. **Conflict Resolution**: `onConflictDoNothing()` for idempotent inserts
3. **Type Safety**: Full TypeScript integration with Drizzle
4. **Error Handling**: Comprehensive error wrapping and logging

## Error Handling & Monitoring

### Global Error Reporting System

The application implements a comprehensive error reporting system that:

1. **Collects Client-Side Errors**: React Error Boundaries send errors to `/api/errors`
2. **Deduplicates Errors**: Groups similar errors by name, message, and component
3. **Environment-Aware**: Different behavior for development vs production
4. **Statistics Tracking**: Provides error analytics and monitoring

### Error Monitoring Integration

**Source**: [`src/lib/monitoring/error-monitoring.ts`](../src/lib/monitoring/error-monitoring.ts)

The system integrates with external services in production:

```typescript
async function forwardToExternalService(
  errorReport: ErrorReport,
): Promise<void> {
  const externalServiceUrl = process.env.EXTERNAL_ERROR_SERVICE_URL;
  const apiKey = process.env.EXTERNAL_ERROR_SERVICE_KEY;

  if (!externalServiceUrl || !apiKey) {
    return; // No external service configured
  }

  await fetch(externalServiceUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      ...errorReport,
      service: "read-by-ear",
      timestamp: new Date(errorReport.timestamp).toISOString(),
    }),
  });
}
```

## Environment Configuration

The application uses a sophisticated environment configuration system.

**Source**: [`src/lib/config/environment.ts`](../src/lib/config/environment.ts)

### Configuration Structure

```typescript
export interface EnvironmentConfig {
  env: Environment;
  isDevelopment: boolean;
  isPreview: boolean;
  isProduction: boolean;
  version: string;
  buildDate: string;
  commitHash?: string;
  services: ServiceEndpoints;
  features: FeatureFlags;
  performance: PerformanceConfig;
  security: SecurityConfig;
  analytics: AnalyticsConfig;
}
```

### Environment Detection

```typescript
private detectEnvironment(): Environment {
  if (typeof window === "undefined") {
    // Server-side detection
    if (process.env.NODE_ENV === "production") {
      return process.env.VERCEL_ENV === "preview" ? "preview" : "production";
    }
    return "development";
  }

  // Client-side detection
  const hostname = window.location.hostname;

  if (hostname === "localhost" || hostname === "127.0.0.1") {
    return "development";
  }

  if (hostname.includes("vercel.app") || hostname.includes("-preview")) {
    return "preview";
  }

  if (hostname === "library.read-by-ear.com") {
    return "production";
  }

  return "development"; // Default fallback
}
```

### Service Endpoints by Environment

```typescript
private getServiceEndpoints(env: Environment): ServiceEndpoints {
  switch (env) {
    case "production":
      return {
        convex:
          process.env.NEXT_PUBLIC_CONVEX_URL ??
          "https://read-by-ear.convex.cloud",
        auth: "https://auth.sara.ai",
        api: "https://library.read-by-ear.com/api",
        cdn: "https://cdn.read-by-ear.com",
      };

    case "preview":
      return {
        convex:
          process.env.NEXT_PUBLIC_CONVEX_URL ??
          "https://read-by-ear-preview.convex.cloud",
        auth: "https://auth-preview.sara.ai",
        api: `https://${process.env.VERCEL_URL ?? "preview.read-by-ear.com"}/api`,
      };

    case "development":
    default:
      return {
        convex:
          process.env.NEXT_PUBLIC_CONVEX_URL ??
          "https://read-by-ear-dev.convex.cloud",
        auth: process.env.NEXT_PUBLIC_AUTH_URL ?? "https://auth-dev.sara.ai",
        api: "http://localhost:3000/api",
      };
  }
}
```

## Best Practices

### 1. Request Validation

Always validate incoming request data with proper TypeScript typing:

```typescript
// Validate request structure
if (!isValidErrorReport(reportData)) {
  return NextResponse.json(
    { error: "Invalid error report format" },
    { status: 400 },
  );
}

function isValidErrorReport(report: unknown): report is ErrorReport {
  if (typeof report !== "object" || report === null) return false;

  const r = report as Record<string, unknown>;

  return (
    typeof r.errorId === "string" &&
    typeof r.timestamp === "number" &&
    typeof r.error === "object" &&
    // ... additional validation
  );
}
```

### 2. Error Handling

Implement comprehensive error handling with proper logging:

```typescript
try {
  // API logic
} catch (error) {
  console.error("[API] Specific operation failed:", error);

  return NextResponse.json(
    {
      error: "User-friendly error message",
      details: error instanceof Error ? error.message : "Unknown error",
    },
    { status: 500 },
  );
}
```

### 3. Environment-Aware Configuration

Use the configuration system to handle different environments:

```typescript
const envConfig = config.getConfig();

if (!envConfig.features.enableErrorReporting) {
  return NextResponse.json(
    { error: "Error reporting disabled" },
    { status: 403 },
  );
}
```

### 4. Type Safety

Leverage TypeScript throughout the API layer:

```typescript
// Define clear interfaces for request/response
interface LearningAuditRequest {
  records: FluencyRecord[];
  studentId: string;
  source?: string;
}

// Use proper typing for request parsing
const body = (await request.json()) as LearningAuditRequest;
```

### 5. Logging and Monitoring

Implement structured logging for debugging and monitoring:

```typescript
console.log(
  `[Audit] Syncing ${validRecords.length} learning records to PostgreSQL`,
  {
    studentId,
    source: source ?? "convex",
    recordCount: validRecords.length,
    words: [...new Set(validRecords.map((r) => r.word))],
  },
);
```

This API tutorial provides comprehensive coverage of the Read-by-Ear API architecture, with real code examples and direct links to the source files. New developers can use this as both a learning resource and a reference guide for understanding and extending the API functionality.

---

**Previous**: [Convex Primer](./03-convex-primer.md) | **Next**: [Hands-on Exercises](./05-hands-on-exercises.md)
